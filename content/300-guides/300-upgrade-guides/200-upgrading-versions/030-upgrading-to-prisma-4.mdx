---
title: 'Upgrade to Prisma 4'
metaTitle: 'Upgrade to Prisma 4'
metaDescription: 'Guides on how to upgrade to Prisma 4'
tocDepth: 2
toc: true
---

<TopBlock>

Prisma 4 introduces a number of **breaking changes** when you upgrade from an Prisma 3 version (`3.x.x`). This guide explains how this upgrade might affect your application and gives instructions on how to handle any changes.

</TopBlock>

## Breaking changes

This section gives an overview of breaking changes in Prisma 4.

### Node.js minimum version change

From v4.0.0, the minimum version of Node.js that we support is 14.x. If you use an earlier version of Node.js, you will need to update it.

See our [system requirements](/reference/system-requirements) for all minimum version requirements.

### Raw query type mapping

In v3.14.x and v.3.15.x, [raw query type mapping](/concepts/components/prisma-client/raw-database-access#raw-query-type-mapping) was available with the Preview feature `improvedQueryRaw`. In v4.0.0, we have made raw query type mapping Generally Available. You do not need to use `improvedQueryRaw` in v4.0.0 or later.
​
From v4.0.0, some data types returned by `queryRaw` or `queryRawUnsafe` are different, as follows:
​
| Data type | Before v4.0.0 | Version 4.0.0 and later |
|-----------|---------------------|-------------------------|
| `DateTime`| Returned as `String` | Returned as `DateTime` |
| `Decimal` | Returned as `Float` | Returned as `Decimal` |
| `Byte` | Returned as `String` | Returned as `Buffer `|
| `BigInt` | Returned as `Integer` | Returned as `BigInt` |

#### Upgrade path

If you use `queryRaw` or `queryRawUnsafe` to return any of the above data types, you must change your code to handle the new types. For example, if you return `DateTime` data, you need to take into account the following in v4.0.0:

- You no longer need to manually instantiate a `DateTime` object for the returned data.
- If your code currently uses the returned `String` data, then you now need to convert the `DateTime` object to a `String`.

You must make equivalent code changes for any of the above data types used by your code.

### <inlineCode>DbNull</inlineCode>, <inlineCode>JsonNull</inlineCode> and <inlineCode>AnyNull</inlineCode> are now objects

JavaScript `null` is ambiguous for JSON columns, so Prisma uses `DbNull`, `JsonNull`, and `AnyNull` to distinguish between the database `NULL` value and the JSON `null` value. From v4.0.0, `DbNull`, `JsonNull`, and `AnyNull` are objects, instead of string constants.

See [Filtering by null values](/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-by-null-values) for more information.

#### Upgrade path

If you use literal strings to address these values, then you must update your code to use the following named constants instead:

- For `DbNull` use `Prisma.DbNull`
- For `JsonNull` use `Prisma.JsonNull`
- For `AnyNull`: use `Prisma.AnyNull`

If you already use these named constants, then you do not need to take any action. If you now get a type error when you pass `Prisma.DbNull` as the value of a JSON field, then this probably indicates a bug in your code that our types did not catch before v4.0.0. The field where you tried to store `DbNull` is probably not nullable in your schema. As a result, a literal "DbNull" string was stored in the database instead of NULL.

### Default composite types in MongoDB

From v4.0.0, if you carry out a database read on a composite type when all of the following conditions are true, then Prisma Client inserts the default value into the result.

Conditions:

- The composite type is required, and
- The composite type has a default value, and
- The database read operation returns the value `undefined`

This behavior is now consistent with the behavior for model fields.

To learn more, see [Default values on required composite types](/concepts/components/prisma-client/composite-types#default-values-on-required-composite-types).

#### Upgrade path

If you currently rely on a return value of `undefined`, then you need to refactor your code to handle the returned default value that is now returned in Prisma 4.

### Prisma no longer exports `Prisma.dmmf.schema` into the generated Prisma Client

From v4.0.0, Prisma no longer exports `Prisma.dmmf.schema` into the generated Prisma Client. This makes the generated Prisma Client much more efficient, and also avoids some memory leaks if you use Jest to carry out tests.

Note:

- This change does not affect the DMMF that Prisma passes to the generators.
- You can retrieve the full DMMF at runtime dynamically.
- We still export `Prisma.dmmf.datamodel` into the generated Prisma Client.

### Index configuration

In Prisma 4, the `extendedIndexes` Preview feature will now become generally available. This includes the following index configuration options:

- Length configuration of indexes, unique constraints and primary key constraints for MySQL (in Preview in versions `3.5.0` and later)
- Sort order configuration of indexes, unique constraints and primary key constraints (in Preview in versions `3.5.0` and later)
- New index types for PostgreSQL: Hash (in Preview in versions `3.6.0` and later) and GIN, GiST, SP-GiST and BRIN (in Preview in versions `3.14.0` and later)
- Index clustering for SQL Server (in Preview in versions `3.13.0` and later)

See our documentation on [Index configuration](/concepts/components/prisma-schema/indexes#index-configuration) for more details of these features.

#### Upgrade path

These can all be breaking changes if you were previously configuring these properties at the database level. In this case, you will need to:

- upgrade to the new Prisma 4 packages following [these instructions](#upgrade-the-prisma-and-prismaclient-packages-to-prisma-4)
- run `prisma db pull` afterwards to retrieve any existing configuration of indexes and constraints. This needs to be done before running any `prisma db push` or `prisma migrate dev` command, or you may lose any configuration that was defined in the database but not previously represented in the Prisma schema.

For more details, see the [Upgrading from previous versions](/concepts/components/prisma-schema/indexes#upgrading-from-previous-versions) section of our index configuration documentation.

### Scalar list defaults

For database connectors that support scalar lists (PostgreSQL, CockroachDB and MongoDB), Prisma 4 introduces the ability to set a default value in your Prisma schema file with the `@default` attribute:

<TabbedContent tabs={[<FileWithIcon text="Relational databases" icon="database"/>, <FileWithIcon text="MongoDB" icon="database"/>]}>
<tab>

```prisma highlight=3;normal
model User {
  id             Int      @id @default(autoincrement())
  posts          Post[]
  favoriteColors String[] @default(["red", "yellow", "purple"])
}
```

</tab>
<tab>

```prisma highlight=3;normal
model User {
  id             String   @id @default(auto()) @map("_id") @db.ObjectId
  posts          Post[]
  favoriteColors String[] @default(["red", "yellow", "purple"])
}
```

</tab>
</TabbedContent>

#### Upgrade path

This is a breaking change if you previously had defaults defined for scalar lists at the database level. In this case, you will need to:

- upgrade to the new Prisma 4 packages following [these instructions](#upgrade-the-prisma-and-prismaclient-packages-to-prisma-4)
- run `prisma db pull` afterwards to retrieve any existing configuration of indexes and constraints. This needs to be done before running any `prisma db push` or `prisma migrate dev` command, or you will lose any defaults that are defined in the database but not previously represented in the Prisma schema.

### Explicit `@unique` constraints on one-to-one relations

When using one-to-one relations in Prisma 4, you will need to explicitly add the `@unique` attribute to the relation scalar field. For example, for this one-to-one relation between a `User` and a `Profile` model, you will need to add the `@unique` attribute to the `profileId` field:

<TabbedContent tabs={[<FileWithIcon text="Relational databases" icon="database"/>, <FileWithIcon text="MongoDB" icon="database"/>]}>
<tab>

```prisma
model User {
  id        Int      @id @default(autoincrement())
  profile   Profile? @relation(fields: [profileId], references: [id])
  profileId Int?     @unique // <-- include this explicitly
}

model Profile {
  id   Int   @id @default(autoincrement())
  user User?
}
```

</tab>
<tab>

```prisma
model User {
  id        String   @id @default(auto()) @map("_id") @db.ObjectId
  profile   Profile? @relation(fields: [profileId], references: [id])
  profileId String?  @unique @db.ObjectId // <-- include this explicitly
}

model Profile {
  id   String @id @default(auto()) @map("_id") @db.ObjectId
  user User?
}
```

</tab>
</TabbedContent>

#### Upgrade path

After you upgrade to Prisma 4, any one-to-one relations without a `@unique` attribute on the relation scalar will trigger a validation error. To upgrade, you will need to:

- upgrade to the new Prisma 4 packages following [these instructions](#upgrade-the-prisma-and-prismaclient-packages-to-prisma-4)
- manually fix the validation errors in your Prisma schema. Alternatively, if you have an up-to-date live database, running `prisma db pull` will add the `@unique` attributes automatically.

### Remove `references` syntax for implicit many-to-many relations

When using [implicit many-to-many relations](/concepts/components/prisma-schema/relations/many-to-many-relations#implicit-many-to-many-relations) in Prisma 4, you will no longer be able to use the `references` argument, which was previously optional. For example, the following relation would now trigger a validation error:

```prisma file=schema.prisma
model Post {
  id         Int        @id @default(autoincrement())
  categories Category[] @relation("my-relation", references: [id]) // <-- validation error
}

model Category {
  id    Int    @id @default(autoincrement())
  posts Post[] @relation("my-relation", references: [id]) // <-- validation error
}
```

Instead, you can write:

```prisma file=schema.prisma
model Post {
  id         Int        @id @default(autoincrement())
  categories Category[] @relation("my-relation")
}

model Category {
  id    Int    @id @default(autoincrement())
  posts Post[] @relation("my-relation")
}
```

This is because the only valid value for `references` was `id`, so removing this argument makes it clearer what can and cannot be changed.

#### Upgrade path

After you upgrade to Prisma 4, any implicit many-to-many relations with a `references` argument will trigger a validation error. To upgrade, you will need to:

- upgrade to the new Prisma 4 packages following [these instructions](#upgrade-the-prisma-and-prismaclient-packages-to-prisma-4)
- manually fix the validation errors in your Prisma schema. Alternatively, if you have an up-to-date live database, running `prisma db pull` will remove the `references` arguments automatically.

## Upgrade the <inlinecode>prisma</inlinecode> and <inlinecode>@prisma/client</inlinecode> packages to Prisma 4

To upgrade to Prisma 4 from a `3.x.x` version, you need to update both the `prisma` and `@prisma/client` packages. Both the `prisma` and `@prisma/client` packages install with a caret `^` in their version number. This allows upgrades to new minor versions, but not major versions, to safeguard against breaking changes.

To ignore the caret `^` and upgrade across major versions, you can use the `@4` tag when you upgrade with `npm`, or `yarn`:

<Admonition type="alert">

Before you upgrade, check each **breaking change** to see how the upgrade might affect your application.

</Admonition>

<TabbedContent tabs={[<FileWithIcon text="npm" icon="file"/>, <FileWithIcon text="yarn" icon="file"/>]}>

<tab>

```terminal
npm install prisma@4 @prisma/client@4
```

</tab>

<tab>

```terminal
yarn upgrade prisma@4 @prisma/client@4
```

</tab>

</TabbedContent>
